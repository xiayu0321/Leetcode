## 比特位计数（简单）

### 题目

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

**提示：**

- `0 <= n <= 105`

**进阶：**

很容易就能实现时间复杂度为 O(n log n) 的解决方案，你可以在线性时间复杂度 O(n) 内用一趟扫描解决此问题吗？
你能不使用任何内置函数解决此问题吗？（如，C++ 中的 __builtin_popcount ）

链接：https://leetcode.cn/problems/counting-bits

### 思路

题目要求计数0至 n 中每个数二进制中1的个数，因此考虑遍历0-n，并且通过bin()函数将其变为二进制字符串，并通过字符串.count()方法统计1的个数，将其添加到 res 列表中，最终遍历完后返回 res 列表。

以上方法利用了内置函数 bin 和 count。

由于题目涉及到二进制位，可以通过位运算的方式进行二进制转换，而无需通过内置函数 bin 函数计算。**注意：对于任意整数 *x*，令 x=x&(x-1)，该运算将 x 的二进制表示的最后一个 1 变成 0。**因此，通过遍历0-n，对每一个数字进行 x=x&(x-1)计算，直到每个数字变为0，此时就能统计出每个数字二进制形式下的1的个数。

