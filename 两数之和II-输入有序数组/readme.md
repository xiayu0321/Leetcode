## 两数之和 II-输入有序数组（中等）

### 题目

给你一个下标从 1 开始的整数数组 numbers ，该数组已按 **非递减顺序排列**  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。

以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。

你可以假设每个输入 **只对应唯一的答案** ，而且你 不可以 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

提示：

* $2 <= numbers.length <= 3 * 10^4$
* -1000 <= numbers[i] <= 1000
* numbers 按 非递减顺序 排列
* -1000 <= target <= 1000
* 仅存在一个有效答案

链接：https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted

### 思路

首先抓住题目主要信息：非递减数组、唯一答案、答案是非重复元素，返回值是下标值+1。

因为题目中是两数之和，因此可以考虑确定第一个元素，然后再去判断第二个元素值是否合适，如果不合适，再调整第一个元素值，直至尝试所有元素。再由于数组是非递减数组，因此可以从右到左依次移动，如果当前遍历值比【 target-第一个元素值】大，就继续移动右边值，直至找到合适元素。

依据以上思想，使用双指针算法，只要 left < right，确定left 所指向的元素为第一个元素，然后以【 target-numbers[left]】寻找合适的第二个元素，比较其与 numbers[right]的大小，如果刚好等于，即可直接返回当前下标+1；如果大于，则left向右移动；否则 right 向左移动。遍历完后如果中途没有返回，就相当于没有找到，则直接返回[-1,-1]

另一种方式是采用二分查找法，同样主要思想也是确定第一个元素，然后以【target-第一个元素】与 mid 所指向的元素进行比较。首先遍历数组，以当前遍历值为第一个元素，然后以此确定 left 和 right，进行二分查找第二个元素。比较 number[mid]和【target-numbers[i]】，如果相等，则返回 i +1 和 mid+1；如果大于，则移动 right；否则移动 left。遍历完后如果中途没有返回，就相当于没有找到，则直接返回[-1,-1]