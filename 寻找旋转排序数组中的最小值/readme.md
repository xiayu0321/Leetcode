## 寻找旋转排序数组中的最小值（中等）

###  题目

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

提示：

* n == nums.length
* 1 <= n <= 5000
* -5000 <= nums[i] <= 5000
* nums 中的所有整数 互不相同
* nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转

链接：https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array

### 思路

首先，参数中的数组是已经经过旋转后的数组，而原数组是升序数组，并且每一次旋转是将最后一个元素放到第一位上。因此，经过旋转后的数组是先递增然后骤减到最小值再递增。综上，可以直接通过遍历旋转后的数组，如果出现第一个比第一位数小的数，那么该数就是旋转数组后的最小值。如果没有出现，那么该数组就是原数组，第一位就是最小值。

根据旋转数组后变化规律和数据的分布趋势，经过旋转后的数组是先递增然后骤减到最小值再递增，同时对于数组中的最后一个元素，最小值左边的元素都大于它，最小值右边的元素都小于它，因此可以使用二分查找方法。设置 left，right 和 mid 指针，比较 mid 和 right 所指向元素的大小。如果 right 元素 > mid元素，说明此时 mid 在最小值的右边，因此移动 right至 mid；如果right 元素 < mid元素，说明此时 mid 在最小值的左边，因此移动 left 至 mid+1。但由于数组中不包含重复元素，并且数组长度不为1，mid 和 right 所指向的元素不会相同。如果当前的区间长度为 1时，则二分查找结束，返回 left 所指向的元素即为最小元素。





