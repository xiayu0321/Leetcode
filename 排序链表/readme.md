## 排序链表（中等）

### 题目

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

提示：

* 链表中节点的数目在范围$ [0, 5 * 10^4]$ 内
* $-10^5 <= Node.val <= 10^5$

进阶：你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

链接：https://leetcode.cn/problems/sort-list

### 思路

排序链表首先想到了头插法，因此需要用哑节点 dummyNode 作为新链表的头；然后排序链表需要找到哪个元素需要移动以及移动到哪个位置，因此，需要遍历链表，通过比较当前元素和当前元素的下一个元素值大小，找到前面大而后面小的元素，即后面小的元素则需要移动。再找到移动元素后再确定需要插入的位置，需要从哑节点遍历，直到找到元素值比移动元素值大的，此时就确定了插入位置。最后再进行插入。此外，一定要将位置指针移动到 dummyNode 处，以方便下一轮从头查找插入位置。另外还需要考虑链表为空的情况，这种情况下就直接返回即可。

以上这种方法时间复杂度高，对于大数量级链表会超出时间限制。

因此，考虑使用字典存储每个节点的值以及对应的数量，即 key 为元素值，value 为该元素在链表中出现的数量，然后将链表按照 key 值进行排序，最后按照字典顺序生成相应的链表节点，并链接起来，形成新的链表返回。在这种情况下，仍然需要考虑链表为空的情况，直接返回即可。

```python
# 重点操作，将字典按照 key 值排序，相应 value 也存在
headmapping = dict(sorted(headmapping.items(), key=operator.itemgetter(0))) 
```

这种方法时间复杂度稍降，可以通过所有用例。

最后一种是看别人实现的归并算法，是链表中的常用的排序算法，主要涉及了递归、快慢指针以及合并有序数组等三大点。

归并排序主要分为三步：首先，找到链表中点，将链表划分为两个子链表。然后，对两个子链表进行排序；最后将两个有序链表合成一个链表。

在递归时，终止条件是链表中只有一个节点或者链表中没有节点了，则无需对链表进行拆分以及排序。



