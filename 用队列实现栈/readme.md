## 用队列实现栈（简单）

### 题目

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

* void push(int x) 将元素 x 压入栈顶。
* int pop() 移除并返回栈顶元素。
* int top() 返回栈顶元素。
* boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。

注意：

* 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
* 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

提示：

- `1 <= x <= 9`
- 最多调用`100` 次 `push`、`pop`、`top` 和 `empty`
- 每次调用 `pop` 和 `top` 都保证栈不为空

链接：https://leetcode-cn.com/problems/implement-stack-using-queues

### 思路

由于栈是先入后出的特性，而队列是先入先出的特性，因此我们需要考虑在入栈时，当前入栈元素必须为队列的队头元素，因此，必须有一个空的队列存放当前入栈元素，然后另一个队列的所有元素全部移动到当前队列中，以保证下一次入栈时元素能进入空队列。这就每次入栈时交换两个队列，即，一个队列作为存储栈内元素队列，另一个队列为入栈辅助队列。

在出栈时，由于存储栈内元素的队列的队头是最新入栈元素，因此出栈就弹出当前存储栈内元素的队列的队头。

查看栈顶元素时，只需要返回存储栈内元素的队列的队头元素，无需删除。

在判断栈是否为空时，只要判断存储栈内元素的队列是否为空。

以上是使用两个队列的方法，还有可以使用一种队列的方法。由于我们需要『当前入栈元素一定在队列的头部』，因此，每次在入队时，可以先知道入队前元素的长度，再入队新元素，然后再将之前的元素弹出，再重新入队，如此就能保证新元素始终在队列头部。其他判断跟两个队列的方式是一致的。