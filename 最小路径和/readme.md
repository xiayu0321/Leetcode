## 最小路径和

### 题目

给定一个包含非负整数的$m*n$ 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

提示：

* m == grid.length
* n == grid[i].length
* 1 <= m, n <= 200
* 0 <= `grid[i][j]` <= 100

链接：https://leetcode.cn/problems/minimum-path-sum

### 思路

由于要找二维数组中左上角到右下角的一条最短路径，因此，可通过计算达到每个元素时的最短路径，然后就能得到最后的完整的最短路径。但由于每次只能向下或者向右移动一步，因此当前元素下的最短路径一般由左一个元素或者上一个元素和当前元素值组成。此时，要考虑到达二维数组边界（左界和上界）的问题。综上，到达当前元素的最小路径值有四种情况：

第一种：i=0和j=0的情况。此时为初始元素，当前元素即为到达该元素的最小路径和。

第二种：i=0的情况。此时当前元素处于上界，因此到达当前元素的路径只能从左边来，因此当前元素的最小路径和`=grid[i][j-1]+当前元素值`

第三种：j=0的情况。此时当前元素处于左界，因此到达当前元素的路径只能从上边来，因此当前元素的最小路径和`=grid[i-1][j]+当前元素值`

第四种：i!=0 and j!=0的情况。此时当前元素未在边界，因此，到达当前元素的路径可从左边和上边来，当前元素的最小路径和`=min(grid[i-1][j],grid[i][j-1])+当前元素值`

在遍历完数组后，数组中存储的即是到达当前元素的最小路径，最后返回二维数组的最后一个元素即可。

```python
    def minPathSum(self, grid: List[List[int]]) -> int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i == 0 and j == 0:
                    continue
                elif i == 0:
                    grid[i][j] = grid[i][j-1] + grid[i][j]
                elif j == 0:
                    grid[i][j] = grid[i-1][j] + grid[i][j]
                else:
                    grid[i][j] = min(grid[i][j-1],grid[i-1][j]) + grid[i][j]
        return grid[-1][-1]
```

