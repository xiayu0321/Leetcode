## 重排链表（中等）

### 题目

给定一个单链表 L 的头节点 head ，单链表 L 表示为：

L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

**提示：**

- 链表的长度范围为 $[1, 5 * 10^4]$
- `1 <= node.val <= 1000`

链接：https://leetcode.cn/problems/reorder-list

### 思路

重排链表其实是将原链表等分为两个链表，然后将后面链表倒序再逐一插入到前面链表中。

第一种思路考虑仅改变元素内容，而不改变节点的链接关系。因此，只需要将节点元素值读入到数组中，根据数组有下标指示的特点，得到前后两个数组，将后面数组进行倒序，最后再遍历链表时，再从两个数组中读取元素逐一给链表元素赋值。

第二种思路数组存储的不是节点元素值，而是存储链表节点，依赖数组下标容易将链表元素分为两组，最后再进行重构链表即可。此时可使用双指针算法，只要i<j，前面数组从小到大依次读取，而后面数组是从大到小依次读取。首先先从前面下标和后面下标取出节点，将其链接，然后将前面数组下标向后移动一个单位，此时判断指针是否重合，如果重合则遍历结束，否则，将链表和新前下标所指向的链表节点链接，再移动后面指针的位置。注意，最后元素的 next 赋值为 None。

第三种算法直接在原链上重排。一共涉及三个知识点：寻找链表中点、链表逆序以及合并链表。在寻找链表中点中可以通过快慢指针实现，快指针一次走两步，而慢指针一次一步，到快指针到达链表末尾时，慢指针恰好指向链表的中点。在链表逆序中，主要是将链表中点到链表末尾之间的节点逆序，通过依次迭代反转 next。最后在合并链表，依次取出两个链表的值进行链接。直至某一链表遍历完。最后将没遍历完的链表的剩余部分链接到最后。

