## 删除排序链表中的重复元素 II

### 题目

给定一个已排序的链表的头 `head` ， 删除原始链表中所有重复数字的节点，只留下不同的数字。返回已排序的链表 。

提示：

- 链表中节点数目在范围 `[0, 300]` 内
- `-100 <= Node.val <= 100`
- 题目数据保证链表已经按升序 **排列**

链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/

### 思路

题目要求要删除所有重复数字的节点，同时原链表是升序的，因此可以在遍历链表的过程中，找到重复数字数字的第一个节点的前序节点和最后一个节点，直接链接前序节点和最后一个节点的下一个元素即可。

由于需要前序节点，因此可以设置哑巴节点作为newHead，newHead.next 为head，即为原链表。此时自然设置 pre 为 newHead，遍历节点p=head，即从原节点的第一个节点开始遍历。由于我的想法需要保存重复元素节点的第一个节点的前序节点和最后一个节点，因此设置两个额外节点 first 和 last 保存对应节点，初始时设置为 None。

在遍历链表的过程（`while(p.next != None)`）中，由于链表本身就是升序的，因此可以通过`p.val == p.next.val and pre.val != p.val`条件找到重复元素节点的第一个节点，此时该节点的 pre 就是第一个重复元素的前序节点，用 first 保存；再通过`pre.val == p.val and p.val != p.next.val`条件找到重复元素节点的最后一个节点，用 last 保存。

只要当`first`和`last`同时存在时，才可以删除first和last中间的所有重复元素，即`first.next = last.next`，同时由于删除了重复元素，此时pre 应该是删除后新链表的前序节点，因此需要重新设置`pre = first`。此外需注意的是：再删除一批元素后，需要将 first 和 last 初始化为 None， 再进行下一轮的寻找。即移动当前指针。

如果当`first`和`last`没有同时存在时，那就意味着还没有找到一组删除的元素，就正常移动前序节点和当前指针。

由于在遍历完链表后，由于最后一个元素的情况没有进行判断，因此可能存在只有first存在的情况，才需要另外判断，即`first.next.val == p.val`, 此时也就是first 到最后一个元素都是重复元素，因此直接将first 之后的元素全部删除，即`first.next = None`。

注意：还要另外排除链表不存在的情况。

最后返回哑节点的 next 即可。







